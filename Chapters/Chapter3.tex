\chapter{Diseño e implementación} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

En este capítulo se detalla el proceso de desarrollo del equipo, incluyendo la arquitectura de la solución como sistema, el firmware embebido, la aplicación de escritorio y el hardware que constituye el router.
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parámetros para configurar el formato del código en los entornos lstlisting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  %extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,	                % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=[ANSI]C,                % the language of the code
  %otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                  % show the filename of files included with \lstinputlisting; also try caption instead of title
  morecomment=[s]{/*}{*/}
}


%----------------------------------------------------------------------------------------

\section{Diagrama en bloques del sistema} \label{diagrama-bloques-sistema}
El trabajo desarrollado consiste en dos grandes bloques. Por un lado se encuentra el firmware (que corre en la plataforma de hardware), y por el otro lado software que corre nativamente en una computadora y se comunica con el firmware. En la figura \ref{fig:sys-arch} se ilustra un diagrama en bloques de la solución implementada.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figures/system-arch.png}
	\caption{Diagrama en bloques del trabajo realizado.}
	\label{fig:sys-arch}
\end{figure}

El firmware se encarga de realizar íntegramente el procesamiento del flujo de datos (mensajes MIDI), mientras que el software actúa como interfaz de configuración del comportamiento del equipo. La comunicación entre ambas es mediante un puerto serie virtual, emulado por la interfaz USB del microcontrolador. A través de una serie de comandos, se modifican las propiedades de una estructura que modela el comportamiento de la aplicación (\texttt{Settings}). En la figura \ref{fig:app-settings} se muestra un diagrama de clases listando todas las estructuras que componen a este modelo.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figures/app-settings.png}
	\caption{Diagrama en clases de las estructuras de datos principales de la aplicación.}
	\label{fig:app-settings}
\end{figure}

Recorriendo el diagrama de menor a mayor jerarquía, se encuentran las siguientes estructuras:
\begin{itemize}
	\item \texttt{Version}: Se utiliza para versionar la imagen de firmware.
	\item \texttt{SystemFilters}: Representa mediante un \texttt{std::bitset} \cite{cppreference:bitset} de 11 bits si los mensajes de sistema deben ser filtrados o no (un bit por cada tipo de mensaje).
	\item \texttt{ChannelFilters}: Cumple la misma funcionalidad que \texttt{SystemFilters}, con la salvedad de que, como los mensajes de canal tienen un canal asociado, esta estructura es un arreglo de dieciséis \texttt{std::bitset} de 7 bits.
	\item \texttt{RouterSettings}: El ruteo entre entradas y salidas también se modela con un \texttt{std::bitset}. Dado que el sistema posee 4 entradas y 8 salidas, esta estructura es un arreglo de cuatro \texttt{std::bitset} de 8 bits.
	\item \texttt{IOSettings}: Esta estructura encapsula todas las propiedades que se pueden modificar en las entradas y salidas: un nombre, la configuración de filtros y si se encuentra habilitada o no.
	\item \texttt{Preset}: Contiene la configuración de todas las entradas y salidas, así como la configuración de ruteo entre ellas. Además se le agrega un nombre para que el usuario también pueda identificarla.
	\item \texttt{Settings}: Contiene el estado de los dieciséis preset, el número de preset activo, la versión y un identificador único que se utiliza para operaciones de serialización.
\end{itemize}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------

\section{Desarrollo del firmware} \label{desarrollo-firmware}

En esta sección se describe la arquitectura del firmware y los componentes que lo integran.

\subsection{Arquitectura del firmware} \label{arquitectura-firmware}
Para desarrollar la aplicación, se segmentó la funcionalidad en distintas capas con diferentes niveles de abstracción. En la figura \ref{fig:fw-layers} se ilustra la segmentación realizada.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.55\textwidth]{./Figures/fw-layers.png}
	\caption{Arquitectura de capas utilizada.}
	\label{fig:fw-layers}
\end{figure}

A continuación se detalla la funcionalidad de cada una de ellas:
\begin{itemize}
	\item \texttt{Hardware}: No es parte del software. Se la incluye en el diagrama para poner en contexto a las siguientes capas.
	\item \texttt{ST HAL}: Es la biblioteca HAL ofrecida por el fabricante del microcontrolador \cite{st:um1725}. Se la usa para configurar el reloj del sistema y los periféricos utilizados. En esta capa se contempla tambien la biblioteca USB desarrollada por ST.
	\item \texttt{freeRTOS}: Es la biblioteca de freeRTOS, también desarrollada por terceros \cite{freertos:rtos-book}.
	\item \texttt{os}: Es un wrapper en C++ de primitivas de kernel tales como colas, tareas o mutex, entre otras. Su funcionalidad es proveer una capa de abstracción sobre el sistema operativo utilizado, así como ofrecer más niveles de personalización, facilidad de uso y seguridad sobre las primitivas encapsuladas.
	\item \texttt{hal}: Es un wrapper en C++ de los periféricos utilizados, tales como UART, GPIO, USB, etc. Al igual que \texttt{os} busca desacoplar el periférico de la plataforma utilizada.
	\item \texttt{svc}: Capa de servicios de la aplicación. Son módulos de mayor nivel que engloban tareas específicas, más relacionadas con los requerimientos de la aplicación.
	\item \texttt{app}: Capa de aplicación. Es la encargada de instanciar todos los servicios de modo de cumplir con los requerimientos del firmware. También define los tipos de datos mencionados en la sección \ref{diagrama-bloques-sistema}.
\end{itemize}

\newpage

En base al esquema de capas propuesto, en la figura \ref{fig:fw-arch} se observa un diagrama en alto nivel de los componentes que integran a la aplicación. En secciones posteriores se realizará un análisis más exhaustivo.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/fw-arch.png}
	\caption{Diagrama en bloques de la aplicación embebida.}
	\label{fig:fw-arch}
\end{figure}

La aplicación consiste en cinco tipos de servicios o sistemas interactuando entre sí:
\begin{enumerate}
	\item \texttt{svc::dial}: Es el encargado de monitorear el estado del encoder rotativo y reportar interacciones con el usuario.
	\item \texttt{svc::led}: Controla los LEDs del panel frontal, con la intención principal de indicar el número de preset activo.
	\item \texttt{svc::storage}: Se encarga de leer y escribir la configuración de la aplicación en la memoria interna del microcontrolador.
	\item \texttt{svc::comms}: Gestiona la comunicación con la computadora. Es la encargada de serializar y deserializar los comandos establecidos por el protocolo diseñado para la comunicación entre el firmware y el software.
	\item \texttt{svc::io}: Es el que controla la recepción y transmisión de mensajes MIDI entre las entradas y las salidas. Esto incluye el ruteo y filtrado de mensajes
\end{enumerate}

Cada uno de estos servicios tiene una serie de dependencias que necesita para operar correctamente. La aplicación es la encargada de instanciarlas e inyectarlas.
Por otro lado, la comunicación entre los servicios y la aplicación se hace mediante el patrón de Objeto Activo \cite{lavender-schmidt:active-object}, en donde una tarea monitorea el estado de una cola de eventos que son procesados de manera diferida. Estos eventos son estructuras de datos generadas asincrónicamente por los servicios, y pueden contener o no información asociada.

\newpage

\subsection{Diseño del servicio de Dial}
El servicio \texttt{svc::dial} se encarga de monitorear un encoder rotativo con pulsador. En la figura \ref{fig:rotary-encoder} se muestra una fotografía de un encoder típico, montado en una placa tipo breakout para prototipos.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.25\textwidth]{./Figures/rotary-encoder.jpg}
	\caption{Encoder rotativo con pulsador\protect\footnotemark.}
	\label{fig:rotary-encoder}
\end{figure}

\footnotetext{Imagen tomada de \url{https://thepihut.com/cdn/shop/articles/DSC_0700.jpg}.}

Estos encoders poseen tres señales: una es el pulsador, y las otras dos, denominadas \texttt{CLK} y \texttt{DT}, generan una onda cuadrada desfasada 90 grados cuando el encoder rota. La fase relativa entre ambas señales determina el sentido de giro del dial.

En la figura \ref{fig:svc-dial} se ilustra un diagrama en bloques del servicio \texttt{svc::dial}. Este consiste en una tarea que muestrea periódicamente tres GPIOs configurados como entradas, aplicando mecanismos de antirrebote y procesamiento de la señal en cuadratura para determinar el estado del dial.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/svc-dial.png}
	\caption{Diagrama en bloques del servicio de Dial.}
	\label{fig:svc-dial}
\end{figure}

Cuando se detecta alguna actividad por parte del usuario, los siguientes eventos son enviados a la aplicación principal:
\begin{itemize}
	\item \texttt{ButtonPressed}: El botón ha sido apretado una sola vez.
	\item \texttt{ButtonDoublePressed}: El botón ha sido apretado dos veces en una ventana de tiempo corta (configurable a través de una constante de compilación).
	\item \texttt{ButtonLongPressed}: El botón ha sido apretado y retenido por un intervalo de tiempo largo (configurable a través de una constante de compilación).
	\item \texttt{DialCW}: El encoder ha rotado en sentido horario.
	\item \texttt{DialCCW}: El encoder ha rotado en sentido antihorario.
\end{itemize}


\subsection{Diseño del servicio de LEDs}
El servicio \texttt{svc::led} está encargado de controlar los dieciséis LEDs del panel frontal. En la figura \ref{fig:svc-led} se ilustra un diagrama en bloque de la estructura del servicio.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{./Figures/svc-led.png}
	\caption{Diagrama en bloques del servicio de LEDs.}
	\label{fig:svc-led}
\end{figure}

El servicio consiste en una tarea que periódicamente refresca el estado de los LEDs. El uso de una tarea permite  realizar animaciones, definidas a través de una FSM (\textit{Finite State Machine}) como la de la figura \ref{fig:svc-led-fsm}.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/svc-led-fsm.png}
	\caption{Máquina de estados del servicio de LEDs.}
	\label{fig:svc-led-fsm}
\end{figure}

Se definieron tres animaciones:
\begin{enumerate}
	\item \texttt{Startup}: Ocurre cuando el sistema inicializa. Hace un barrido por todos los LEDs, comenzando y terminando por el LED correspondiente al preset activo. Cuando finaliza la animación se transiciona al estado \texttt{Steady}.
	\item \texttt{Steady}: Es el estado por defecto del sistema. Se mantiene encendido el LED correspondiente al preset activo. El servicio dispone de una función llamada \texttt{set\_active\_preset()} para poder actualizar el LED a encender.
	\item \texttt{Blink}: Este estado se utiliza para indicarle al usuario que un preset ha sido guardado como activo, invocando el método \texttt{confirm\_saved()}. La animación consiste en hacer un destello intermitente dos veces. Cuando finaliza, se transiciona al estado \texttt{Steady}.
\end{enumerate}

\newpage

\subsection{Diseño del servicio de almacenamiento}
La función de \texttt{svc::storage} es la de ofrecer una interfaz para leer y escribir la configuración del sistema, modelada mediante la estructura \texttt{app::Settings} mencionada en la sección \ref{diagrama-bloques-sistema}. En la figura \ref{fig:svc-storage} se ilustra un diagrama en bloques del servicio.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{./Figures/svc-storage.png}
	\caption{Diagrama en bloques del servicio de almacenamiento.}
	\label{fig:svc-storage}
\end{figure}

\subsection{Diseño del servicio de I/O}
El servicio \texttt{svc::io} es el núcleo de la aplicación, ya que es el encargado de procesar el flujo de mensajes MIDI desde las entradas hasta las salidas. En la figura \ref{fig:svc-io} se observa un diagrama en bloques del mismo.
\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/svc-io.png}
	\caption{Diagrama en bloques del servicio de I/O.}
	\label{fig:svc-io}
\end{figure}

Dado que hay UARTs que operan como entrada o como entrada-salida, el servicio de I/O admite distintas especializaciones, determinadas por el parámetro \texttt{Mode}, que puede ser \texttt{Input} (solo entrada), \texttt{Output} (solo salida) o \texttt{InputOutput} (entrada y salida). Si el servicio admite entrada, se instanciará una tarea que se encarga de procesar los mensajes provenientes de la UART. Por otra parte, si el servicio admite salida, se instanciará una tarea que se encarga de procesar los mensajes recibidos y transmitirlos por la UART.

El flujo de entrada-salida sigue un patrón de diseño conocido como segmentación de procesos. Este permite transformar datos de una representación a otra mientras se mueven secuencialmente desde un productor a un consumidor \cite{sommerville:ingenieria-sw}. Para ilustrar este concepto, en las figuras \ref{fig:svc-in-pipe} y \ref{fig:svc-out-pipe} se representan los flujos de datos en las tareas de recepción y transmisión de mensajes, respectivamente.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/svc-in-pipe.png}
	\caption{Flujo de datos para la recepción de mensajes MIDI.}
	\label{fig:svc-in-pipe}
\end{figure}

La tarea de recepción involucra más pasos, ya que es necesario convertir la información binaria recibida por la UART en mensajes MIDI. Para ello, se cuenta con una clase llamada \texttt{app::Parser} encargada de convertir una secuencia de bytes en una secuencia de mensajes MIDI. Una vez detectados los tipos de mensaje recibidos, se procede a filtrarlos. La clase \texttt{app::Filter} verifica en la configuración de usuario si el mensaje se encuentra bloqueado. En caso negativo, se transmite a la siguiente etapa, donde la clase \texttt{app::Router} consulta en la configuración a qué salidas debe propagarse. Como los procesos de recepción y transmisión se gestionan en tareas diferentes, y dado que más de una tarea de entrada puede escribir en una tarea de salida, se utilizan colas de mensajes como mecanismo de sincronización para enviar los mensajes MIDI desde las entradas hacia las salidas. FreeRTOS garantiza que estas estructuras son aptas para situaciones de concurrencia \cite{freertos:queues}.


El proceso de transmisión involucra menos pasos, tal como puede observarse en la figura \ref{fig:svc-out-pipe}. La tarea permanece bloqueada hasta que aparezcan mensajes en la cola. Ante la presencia de ellos se procede a consultar la configuración del filtro de la salida. Si el mensaje no debe ser bloqueado, se procede a transmitirlo por el puerto serie. Para ello es necesario serializar primero el mensaje, responsabilidad de la clase \texttt{app::Serializer}.
\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/svc-out-pipe.png}
	\caption{Flujo de datos para la transmisión de mensajes MIDI.}
	\label{fig:svc-out-pipe}
\end{figure}

Una vez que el mensaje fue serializado, se copia su contenido en el buffer circular de la UART para su posterior transmisión, dando por finalizado el proceso.

\subsection{Diseño del servicio de comunicación}

%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------

\section{Desarrollo del software} % 1 página

%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------

\section{Desarrollo del hardware} % 1 página

%----------------------------------------------------------------------------------------




