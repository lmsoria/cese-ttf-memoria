\chapter{Diseño e implementación} % Main chapter title

\label{Chapter3} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

En este capítulo se detalla el proceso de desarrollo del equipo, incluyendo la arquitectura de la solución como sistema, el firmware embebido, la aplicación de escritorio y el hardware que constituye el router.
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% parámetros para configurar el formato del código en los entornos lstlisting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{mygreen},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  %escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  %extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
  %frame=single,	                % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{blue},       % keyword style
  language=[ANSI]C,                % the language of the code
  %otherkeywords={*,...},           % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=1,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,	                   % sets default tabsize to 2 spaces
  title=\lstname,                  % show the filename of files included with \lstinputlisting; also try caption instead of title
  morecomment=[s]{/*}{*/}
}


%----------------------------------------------------------------------------------------

\section{Diagrama en bloques del sistema} \label{diagrama-bloques-sistema}
El trabajo desarrollado consiste en dos grandes bloques. Por un lado se encuentra el firmware (que corre en la plataforma de hardware), y por el otro lado software que corre nativamente en una computadora y se comunica con el firmware. En la figura \ref{fig:sys-arch} se ilustra un diagrama en bloques de la solución implementada.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.75\textwidth]{./Figures/system-arch.png}
	\caption{Diagrama en bloques del trabajo realizado.}
	\label{fig:sys-arch}
\end{figure}

El firmware se encarga de realizar íntegramente el procesamiento del flujo de datos (mensajes MIDI), mientras que el software actúa como interfaz de configuración del comportamiento del equipo. La comunicación entre ambas es mediante un puerto serie virtual, emulado por la interfaz USB del microcontrolador. A través de una serie de comandos, se modifican las propiedades de una estructura que modela el comportamiento de la aplicación (\texttt{Settings}). En la figura \ref{fig:app-settings} se muestra un diagrama de clases listando todas las estructuras que componen a este modelo.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/app-settings.png}
	\caption{Diagrama en clases de las estructuras de datos principales de la aplicación.}
	\label{fig:app-settings}
\end{figure}

Recorriendo el diagrama de menor a mayor jerarquía, se encuentran las siguientes estructuras:
\begin{itemize}
	\item \texttt{Version}: se utiliza para versionar la imagen de firmware.
	\item \texttt{SystemFilters}: representa mediante un \texttt{std::bitset} \cite{cppreference:bitset} de 11 bits si los mensajes de sistema deben ser filtrados o no (un bit por cada tipo de mensaje).
	\item \texttt{ChannelFilters}: cumple la misma funcionalidad que \texttt{SystemFilters}, con la salvedad de que, como los mensajes de canal tienen un canal asociado, esta estructura es un arreglo de dieciséis \texttt{std::bitset} de 7 bits.
	\item \texttt{RouterSettings}: el ruteo entre entradas y salidas también se modela con un \texttt{std::bitset}. Dado que el sistema posee 4 entradas y 8 salidas, esta estructura es un arreglo de cuatro \texttt{std::bitset} de 8 bits.
	\item \texttt{IOSettings}: esta estructura encapsula todas las propiedades que se pueden modificar en las entradas y salidas: un nombre, la configuración de filtros y si se encuentra habilitada o no.
	\item \texttt{Preset}: contiene la configuración de todas las entradas y salidas, así como la configuración de ruteo entre ellas. Además se le agrega un nombre para que el usuario también pueda identificarla.
	\item \texttt{Settings}: contiene el estado de los dieciséis preset, el número de preset activo, la versión y un identificador único que se utiliza para operaciones de serialización.
\end{itemize}
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------

\section{Desarrollo del firmware} \label{desarrollo-firmware}

En esta sección se describe la arquitectura del firmware y los componentes que lo integran.

\subsection{Arquitectura del firmware} \label{arquitectura-firmware}
Para desarrollar la aplicación, se segmentó la funcionalidad en distintas capas con diferentes niveles de abstracción. En la figura \ref{fig:fw-layers} se ilustra la segmentación realizada.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.55\textwidth]{./Figures/fw-layers.png}
	\caption{Arquitectura de capas utilizada.}
	\label{fig:fw-layers}
\end{figure}

A continuación, se detalla la funcionalidad de cada una de ellas:
\begin{itemize}
	\item \texttt{Hardware}: no es parte del software. Se la incluye en el diagrama para poner en contexto a las siguientes capas.
	\item \texttt{ST HAL}: es la biblioteca HAL ofrecida por el fabricante del microcontrolador \cite{st:um1725}. Se la usa para configurar el reloj del sistema y los periféricos utilizados. En esta capa se contempla tambien la biblioteca USB desarrollada por ST.
	\item \texttt{freeRTOS}: es la biblioteca de freeRTOS, también desarrollada por terceros \cite{freertos:rtos-book}.
	\item \texttt{os}: es un wrapper en C++ de primitivas de kernel tales como colas, tareas o mutex, entre otras. Su funcionalidad es proveer una capa de abstracción sobre el sistema operativo utilizado, así como ofrecer más niveles de personalización, facilidad de uso y seguridad sobre las primitivas encapsuladas.
	\item \texttt{hal}: es un wrapper en C++ de los periféricos utilizados, tales como UART, GPIO, USB, etc. Al igual que \texttt{os} busca desacoplar el periférico de la plataforma utilizada.
	\item \texttt{svc}: capa de servicios de la aplicación. Son módulos de mayor nivel que engloban tareas específicas, más relacionadas con los requerimientos de la aplicación.
	\item \texttt{app}: capa de aplicación. Es la encargada de instanciar todos los servicios de modo de cumplir con los requerimientos del firmware. También define los tipos de datos mencionados en la sección \ref{diagrama-bloques-sistema}.
\end{itemize}

En base al esquema de capas propuesto, en la figura \ref{fig:fw-arch} se observa un diagrama en alto nivel de los componentes que integran a la aplicación. En secciones posteriores se realizará un análisis más exhaustivo.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/fw-arch.png}
	\caption{Diagrama en bloques de la aplicación embebida.}
	\label{fig:fw-arch}
\end{figure}

La aplicación consiste en cinco tipos de servicios o sistemas interactuando entre sí:
\begin{enumerate}
	\item \texttt{svc::dial}: es el encargado de monitorear el estado del encoder rotativo y reportar interacciones con el usuario.
	\item \texttt{svc::led}: controla los LEDs del panel frontal, con la intención principal de indicar el número de preset activo.
	\item \texttt{svc::storage}: se encarga de leer y escribir la configuración de la aplicación en la memoria interna del microcontrolador.
	\item \texttt{svc::comms}: gestiona la comunicación con la computadora. Es la encargada de serializar y deserializar los comandos establecidos por el protocolo diseñado para la comunicación entre el firmware y el software.
	\item \texttt{svc::io}: es el que controla la recepción y transmisión de mensajes MIDI entre las entradas y las salidas. Esto incluye el ruteo y filtrado de mensajes
\end{enumerate}

Cada uno de estos servicios tiene una serie de dependencias que necesita para operar correctamente. La aplicación es la encargada de instanciarlas e inyectarlas.
Por otro lado, la comunicación entre los servicios y la aplicación se hace mediante el patrón de Objeto Activo \cite{lavender-schmidt:active-object}, en donde una tarea monitorea el estado de una cola de eventos que son procesados de manera diferida. Estos eventos son estructuras de datos generadas asincrónicamente por los servicios, y pueden contener o no información asociada.

\subsection{Diseño del servicio de dial}
El servicio \texttt{svc::dial} se encarga de monitorear un encoder rotativo con pulsador. En la figura \ref{fig:rotary-encoder} se muestra una fotografía de un encoder típico, montado en una placa tipo breakout para prototipos.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.25\textwidth]{./Figures/rotary-encoder.jpg}
	\caption{Encoder rotativo con pulsador\protect\footnotemark.}
	\label{fig:rotary-encoder}
\end{figure}

\footnotetext{Imagen tomada de \url{https://thepihut.com/cdn/shop/articles/DSC_0700.jpg}.}

Estos encoders poseen tres señales: una es el pulsador, y las otras dos, denominadas \texttt{CLK} y \texttt{DT}, generan una onda cuadrada desfasada 90 grados cuando el encoder rota. La fase relativa entre ambas señales determina el sentido de giro del dial.

En la figura \ref{fig:svc-dial} se ilustra un diagrama en bloques del servicio \texttt{svc::dial}. Este consiste en una tarea que muestrea periódicamente tres GPIOs configurados como entradas, aplicando mecanismos de antirrebote y procesamiento de la señal en cuadratura para determinar el estado del dial.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/svc-dial.png}
	\caption{Diagrama en bloques del servicio de dial.}
	\label{fig:svc-dial}
\end{figure}

Cuando se detecta alguna actividad por parte del usuario, los siguientes eventos son enviados a la aplicación principal:
\begin{itemize}
	\item \texttt{ButtonPressed}: el botón ha sido apretado una sola vez.
	\item \texttt{ButtonDoublePressed}: el botón ha sido apretado dos veces en una ventana de tiempo corta (configurable a través de una constante de compilación).
	\item \texttt{ButtonLongPressed}: el botón ha sido apretado y retenido por un intervalo de tiempo largo (configurable a través de una constante de compilación).
	\item \texttt{DialCW}: el encoder ha rotado en sentido horario.
	\item \texttt{DialCCW}: el encoder ha rotado en sentido antihorario.
\end{itemize}


\subsection{Diseño del servicio de LEDs}
El servicio \texttt{svc::led} está encargado de controlar los dieciséis LEDs del panel frontal. En la figura \ref{fig:svc-led} se ilustra un diagrama en bloque de la estructura del servicio.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{./Figures/svc-led.png}
	\caption{Diagrama en bloques del servicio de LEDs.}
	\label{fig:svc-led}
\end{figure}

El servicio consiste en una tarea que periódicamente refresca el estado de los LEDs. El uso de una tarea permite  realizar animaciones, definidas a través de una FSM (\textit{Finite State Machine}) como la de la figura \ref{fig:svc-led-fsm}.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/svc-led-fsm.png}
	\caption{Máquina de estados del servicio de LEDs.}
	\label{fig:svc-led-fsm}
\end{figure}

Se definieron tres animaciones:
\begin{enumerate}
	\item \texttt{Startup}: ocurre cuando el sistema inicializa. Hace un barrido por todos los LEDs, comenzando y terminando por el LED correspondiente al preset activo. Cuando finaliza la animación se transiciona al estado \texttt{Steady}.
	\item \texttt{Steady}: es el estado por defecto del sistema. Se mantiene encendido el LED correspondiente al preset activo. El servicio dispone de una función llamada \texttt{set\_active\_preset()} para poder actualizar el LED a encender.
	\item \texttt{Blink}: este estado se utiliza para indicarle al usuario que un preset ha sido guardado como activo, invocando el método \texttt{confirm\_saved()}. La animación consiste en hacer un destello intermitente dos veces. Cuando finaliza, se transiciona al estado \texttt{Steady}.
\end{enumerate}

\newpage

\subsection{Diseño del servicio de almacenamiento}
La función de \texttt{svc::storage} es la de ofrecer una interfaz para leer y escribir la configuración del sistema, modelada mediante la estructura \texttt{app::Settings} mencionada en la sección \ref{diagrama-bloques-sistema}. En la figura \ref{fig:svc-storage} se ilustra un diagrama en bloques del servicio.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.6\textwidth]{./Figures/svc-storage.png}
	\caption{Diagrama en bloques del servicio de almacenamiento.}
	\label{fig:svc-storage}
\end{figure}

\subsection{Diseño del servicio de I/O}
El servicio \texttt{svc::io} es el núcleo de la aplicación, ya que es el encargado de procesar el flujo de mensajes MIDI desde las entradas hasta las salidas. En la figura \ref{fig:svc-io} se observa un diagrama en bloques del servicio.
\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/svc-io.png}
	\caption{Diagrama en bloques del servicio de I/O.}
	\label{fig:svc-io}
\end{figure}

Dado que hay UARTs que operan como entrada o como entrada-salida, el servicio de I/O admite distintas especializaciones, determinadas por el parámetro \texttt{Mode}, que puede ser \texttt{Input} (solo entrada), \texttt{Output} (solo salida) o \texttt{InputOutput} (entrada y salida). Si el servicio admite entrada, se instanciará una tarea que se encarga de procesar los mensajes provenientes de la UART. Por otra parte, si el servicio admite salida, se instanciará una tarea que se encarga de procesar los mensajes recibidos y transmitirlos por la UART.

El flujo de entrada-salida sigue un patrón de diseño conocido como segmentación de procesos. Este permite transformar datos de una representación a otra mientras se mueven secuencialmente desde un productor a un consumidor \cite{sommerville:ingenieria-sw}. Para ilustrar este concepto, en las figuras \ref{fig:svc-in-pipe} y \ref{fig:svc-out-pipe} se representan los flujos de datos en las tareas de recepción y transmisión de mensajes, respectivamente.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/svc-in-pipe.png}
	\caption{Flujo de datos para la recepción de mensajes MIDI.}
	\label{fig:svc-in-pipe}
\end{figure}

La tarea de recepción involucra más pasos, ya que es necesario convertir la información binaria recibida por la UART en mensajes MIDI. Para ello, se cuenta con una clase llamada \texttt{app::Parser} encargada de convertir una secuencia de bytes en una secuencia de mensajes MIDI. Una vez detectados los tipos de mensaje recibidos, se procede a filtrarlos. La clase \texttt{app::Filter} verifica en la configuración de usuario si el mensaje se encuentra bloqueado. En caso negativo, se transmite a la siguiente etapa, donde la clase \texttt{app::Router} consulta en la configuración a qué salidas debe propagarse. Como los procesos de recepción y transmisión se gestionan en tareas diferentes, y dado que más de una tarea de entrada puede escribir en una tarea de salida, se utilizan colas de mensajes como mecanismo de sincronización para enviar los mensajes MIDI desde las entradas hacia las salidas. FreeRTOS garantiza que estas estructuras son aptas para situaciones de concurrencia \cite{freertos:queues}.


El proceso de transmisión involucra menos pasos, tal como puede observarse en la figura \ref{fig:svc-out-pipe}. La tarea permanece bloqueada hasta que aparezcan mensajes en la cola. Ante la presencia de ellos se procede a consultar la configuración del filtro de la salida. Si el mensaje no debe ser bloqueado, se procede a transmitirlo por el puerto serie. Para ello es necesario serializar primero el mensaje, responsabilidad de la clase \texttt{app::Serializer}.
\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/svc-out-pipe.png}
	\caption{Flujo de datos para la transmisión de mensajes MIDI.}
	\label{fig:svc-out-pipe}
\end{figure}

Una vez que el mensaje fue serializado, se copia su contenido en el buffer circular de la UART para su posterior transmisión, dando por finalizado el proceso.

\subsection{Diseño del servicio de comunicación}
El servicio \texttt{svc::comms} es el encargado de gestionar la comunicación con la aplicación de escritorio mediante la emulación de un puerto serie virtual por USB. En la figura \ref{fig:svc-comms} se observa un diagrama en bloques del servicio.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/svc-comms.png}
	\caption{Diagrama en bloques del servicio de comunicación.}
	\label{fig:svc-comms}
\end{figure}

A grandes rasgos el servicio se compone de dos tareas: una encargada de la recepción y deserialización de comandos, y la otra encargada de la serialización y transmisión de respuestas. La definición de los comandos, respuestas y las funciones de serialización y deserialización se desarrollaron en una biblioteca independiente llamada \texttt{protocol}, que también es compartida con la aplicación. En la figura \ref{fig:proto-command} se ilustra un diagrama de clases de las estructuras definidas en el protocolo.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.8\textwidth]{./Figures/proto-command.png}
	\caption{Estructuras utilizadas en el protocolo de comandos.}
	\label{fig:proto-command}
\end{figure}

Un mensaje (\texttt{proto::Packet<T>}) es una plantilla de clase que consiste de un encabezado (\texttt{proto::Header}), el contenido del mensaje y un código CRC (\textit{Cyclic Redundancy Check}) que se utiliza para verificar la integridad del contenido. El encabezado es a su vez otra estructura que contiene información sobre el tipo de mensaje (identificado mediante una enumeración llamada \texttt{CommandID}) y la cantidad de bytes que ocupa el contenido. Por otro lado, para detectar el comienzo de una trama se agrego un campo llamado \texttt{magic} que contiene un valor fijo de 32 bits. Cuando se encuentre esa secuencia en un buffer el deserializador puede detectar el encabezado y proceder con la decodificación. Finalmente, para garantizar compatibilidad a futuro, se agrego un campo que representa la versión del protocolo.

El contenido de cada mensaje es a su vez una estructura que contiene la información necesaria para procesar cada comando. Una vez decodificados, se envían eventos a la aplicación principal para hacer el procesamiento y generar la respuesta a enviar.

%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------

\section{Desarrollo del software} % 1 página

En esta sección se describe el desarrollo de la aplicación de escritorio, desarrollada con el framework Qt6.

\subsection{Arquitectura de la aplicación}

La aplicación consiste en un único hilo que instancia todas las clases necesarias para la operación por parte del usuario. En la figura \ref{fig:sw-arch} se ilustra un diagrama con los bloques principales.

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.9\textwidth]{./Figures/sw-arch.png}
	\caption{Diagrama en bloques de la aplicación.}
	\label{fig:sw-arch}
\end{figure}

Para integrar las funcionalidades disponibles por Qt, las clases desarrolladas por los consumidores deben heredar de primitivas expuestas por la API (\textit{Application Public Interface}), siendo la más fundamental de ellas \texttt{QObject} \cite{qt:qobject}. Esta clase da acceso a mecanismos de comunicación entre clases mediante señales, incorporación de metadatos y organización del ciclo de vida mediante árboles de jerarquía, entre otras características \cite{qt:object-model}.

Dado que Qt es un framework extenso, no es necesario utilizar todas las bibliotecas que ofrece. Para este trabajo se utilizaron tres:
\begin{enumerate}
	\item \texttt{Qt6::Core}: es la biblioteca que provee la funcionalidad no gráfica fundamental de Qt. Incluye el sistema de objetos basado en \texttt{QObject}, el mecanismo de señales, contenedores y utilidades para entrada/salida básica, entre otros servicios. Todas las clases de la aplicación dependen de este módulo, que funciona como capa de soporte sobre la cual se construyen las demás funcionalidades \cite{qt:core}.
	
	\item \texttt{Qt6::SerialPort}: es la biblioteca que abstrae el acceso a puertos serie de forma portable. Permite configurar parámetros como velocidad, cantidad de bits de datos, paridad y bits de parada, y ofrece operaciones de lectura y escritura mediante la clase \texttt{QSerialPort}. En la aplicación se utiliza para establecer el canal de comunicación entre la computadora y el equipo embebido a través del enlace serie–USB, y encapsula los detalles específicos del sistema operativo \cite{qt:serialport}.
	
	\item \texttt{Qt6::Quick}: es el módulo orientado al desarrollo de interfaces gráficas declarativas mediante QML. Proporciona los tipos básicos para definir componentes visuales, gestionar la entrada del usuario, organizar modelos y vistas de datos y aplicar animaciones y transiciones. En este trabajo se utiliza para implementar la interfaz de usuario de la aplicación \cite{qt:quick}.
\end{enumerate}

Además, se reutilizó la biblioteca \texttt{protocol} utilizada en el firmware para tener acceso a los tipos de datos que representan los comandos, así como los mecanismos de serialización y deserialización.

La aplicación consiste en tres grandes módulos, cada uno con responsabilidades definidas:
\begin{enumerate}
	\item Un gestor del puerto serie, llamado \texttt{SerialPortManager}.
	\item Un gestor de protocolo, llamado \texttt{ProtocolManager}.
	\item La interfaz de usuario, desarrollada en QML.
\end{enumerate}

Asimismo, se desarrollaron wrappers de los tipos de datos utilizados por el firmware (figura \ref{fig:app-settings}), con el objetivo de extender sus propiedades y exponerlas de forma adecuada a la interfaz gráfica basada en QML. Estos wrappers se implementaron como clases derivadas de \texttt{QObject}, con propiedades declaradas mediante el sistema de metadatos de Qt (por ejemplo, \texttt{Q\_PROPERTY}) \cite{qt:qobject}. De este modo, la capa de presentación puede establecer enlaces entre los elementos visuales y dichos atributos, utilizar estas clases como modelos de datos en listas y formularios, y reflejar en pantalla las modificaciones del estado interno de la aplicación.

\pagebreak

\subsection{Diseño del gestor del puerto serie}
Para controlar el acceso a los puertos serie, la biblioteca \texttt{Qt6::SerialPort} ofrece clases dedicadas, siendo \texttt{QSerialPort} la principal \cite{qt:qserialport}. Esta clase permite configurar los parámetros del puerto serie y realizar operaciones de lectura y escritura. El rol del gestor de puerto serie es envolver a esta clase. En la figura \ref{fig:serial-port-manager} se observa un diagrama de la clase \texttt{SerialPortManager} con sus métodos y propiedades más importantes. 

\begin{figure}[ht]
	\centering
	\includegraphics[width=0.4\textwidth]{./Figures/serial-port-manager.png}
	\caption{Diagrama de la clase \texttt{SerialPortManager}.}
	\label{fig:serial-port-manager}
\end{figure}

\subsection{Diseño del gestor de protocolo}
El gestor de protocolo actúa como un puente entre \texttt{SerialPortManager} y la interfaz gráfica. Es el encargado de decodificar los bytes recibidos, convertirlos en comandos y modificar una variable de tipo \texttt{app::Settings}, de forma tal que refleje constantemente el estado del firmware. En la figura \ref{fig:protocol-manager} se observa un diagrama de la clase \texttt{ProtocolManager}.
\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/protocol-manager.png}
	\caption{Diagrama de la clase \texttt{ProtocolManager}.}
	\label{fig:protocol-manager}
\end{figure}

De manera equivalente, la interacción del usuario en los elementos de la interfaz gráfica dispara señales que invocan métodos en \texttt{ProtocolManager}. Estas funciones se traducen en comandos que son serializados y enviados a través de \texttt{SerialPortManager}. 

\subsection{Diseño de la interfaz gráfica}
Para el desarrollo de la interfaz gráfica se utilizó QML, un lenguaje declarativo con una sintaxis similar a JavaScript. Qt ofrece un módulo llamado \texttt{QtQuick Controls} que permite utilizar componentes estándar como botones, entradas de texto y sliders, entre otros \cite{qt:quickcontrols}. Estos componentes ofrecen un tema visual definido por el sistema operativo. Sin embargo, la documentación detalla cómo se pueden personalizar para ofrecer un aspecto más acorde a los requerimientos de UX/UI (\textit{User Experience/User Interface}). En la figura \ref{fig:ui} se muestra el aspecto final de la interfaz gráfica desarrollada.

\begin{figure}[ht]
	\centering
	\includegraphics[width=\textwidth]{./Figures/ui.png}
	\caption{Captura de pantalla de la aplicación diseñada.}
	\label{fig:ui}
\end{figure}

La aplicación consiste en tres sectores: en la parte superior se encuentra un widget cuya función es conectarse con el router, a la izquierda se muestra una lista que permite elegir el preset activo, y en el área central se muestra el estado del preset, usando matrices de checkboxes para configurar las opciones de ruteo y filtrado de mensajes.
%----------------------------------------------------------------------------------------

%----------------------------------------------------------------------------------------

\section{Desarrollo del hardware} % 1 página

%----------------------------------------------------------------------------------------




